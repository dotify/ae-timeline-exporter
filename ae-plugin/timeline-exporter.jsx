if (typeof JSON !== 'object') {  JSON = {};}(function () {  'use strict';  function f(n) {    // Format integers to have at least two digits.    return n < 10 ? '0' + n : n;  }  if (typeof Date.prototype.toJSON !== 'function') {    Date.prototype.toJSON = function () {      return isFinite(this.valueOf())        ? this.getUTCFullYear()     + '-' +          f(this.getUTCMonth() + 1) + '-' +          f(this.getUTCDate())      + 'T' +          f(this.getUTCHours())     + ':' +          f(this.getUTCMinutes())   + ':' +          f(this.getUTCSeconds())   + 'Z'        : null;    };    String.prototype.toJSON      =      Number.prototype.toJSON  =      Boolean.prototype.toJSON = function () {        return this.valueOf();      };  }  var cx,    escapable,    gap,    indent,    meta,    rep;  function quote(string) {// If the string contains no control characters, no quote characters, and no// backslash characters, then we can safely slap some quotes around it.// Otherwise we must also replace the offending characters with safe escape// sequences.    escapable.lastIndex = 0;    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {      var c = meta[a];      return typeof c === 'string'        ? c        : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);    }) + '"' : '"' + string + '"';  }  function str(key, holder) {// Produce a string from holder[key].    var i,          // The loop counter.      k,          // The member key.      v,          // The member value.      length,      mind = gap,      partial,      value = holder[key];// If the value has a toJSON method, call it to obtain a replacement value.    if (value && typeof value === 'object' &&        typeof value.toJSON === 'function') {      value = value.toJSON(key);    }// If we were called with a replacer function, then call the replacer to// obtain a replacement value.    if (typeof rep === 'function') {      value = rep.call(holder, key, value);    }// What happens next depends on the value's type.    switch (typeof value) {    case 'string':      return quote(value);    case 'number':// JSON numbers must be finite. Encode non-finite numbers as null.      return isFinite(value) ? String(value) : 'null';    case 'boolean':    case 'null':// If the value is a boolean or null, convert it to a string. Note:// typeof null does not produce 'null'. The case is included here in// the remote chance that this gets fixed someday.      return String(value);// If the type is 'object', we might be dealing with an object or an array or// null.    case 'object':// Due to a specification blunder in ECMAScript, typeof null is 'object',// so watch out for that case.      if (!value) {        return 'null';      }// Make an array to hold the partial results of stringifying this object value.      gap += indent;      partial = [];// Is the value an array?      if (Object.prototype.toString.apply(value) === '[object Array]') {// The value is an array. Stringify every element. Use null as a placeholder// for non-JSON values.        length = value.length;        for (i = 0; i < length; i += 1) {          partial[i] = str(i, value) || 'null';        }// Join all of the elements together, separated with commas, and wrap them in// brackets.        v = partial.length === 0          ? '[]'          : gap          ? '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']'          : '[' + partial.join(',') + ']';        gap = mind;        return v;      }// If the replacer is an array, use it to select the members to be stringified.      if (rep && typeof rep === 'object') {        length = rep.length;        for (i = 0; i < length; i += 1) {          if (typeof rep[i] === 'string') {            k = rep[i];            v = str(k, value);            if (v) {              partial.push(quote(k) + (gap ? ': ' : ':') + v);            }          }        }      } else {// Otherwise, iterate through all of the keys in the object.        for (k in value) {          if (Object.prototype.hasOwnProperty.call(value, k)) {            v = str(k, value);            if (v) {              partial.push(quote(k) + (gap ? ': ' : ':') + v);            }          }        }      }// Join all of the member texts together, separated with commas,// and wrap them in braces.      v = partial.length === 0        ? '{}'        : gap        ? '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}'        : '{' + partial.join(',') + '}';      gap = mind;      return v;    }  }// If the JSON object does not yet have a stringify method, give it one.  if (typeof JSON.stringify !== 'function') {    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;    meta = {    // table of character substitutions      '\b': '\\b',      '\t': '\\t',      '\n': '\\n',      '\f': '\\f',      '\r': '\\r',      '"' : '\\"',      '\\': '\\\\'    };    JSON.stringify = function (value, replacer, space) {// The stringify method takes a value and an optional replacer, and an optional// space parameter, and returns a JSON text. The replacer can be a function// that can replace values, or an array of strings that will select the keys.// A default replacer method can be provided. Use of the space parameter can// produce text that is more easily readable.      var i;      gap = '';      indent = '';// If the space parameter is a number, make an indent string containing that// many spaces.      if (typeof space === 'number') {        for (i = 0; i < space; i += 1) {          indent += ' ';        }// If the space parameter is a string, it will be used as the indent string.      } else if (typeof space === 'string') {        indent = space;      }// If there is a replacer, it must be a function or an array.// Otherwise, throw an error.      rep = replacer;      if (replacer && typeof replacer !== 'function' &&          (typeof replacer !== 'object' ||          typeof replacer.length !== 'number')) {        throw new Error('JSON.stringify');      }// Make a fake root object containing our value under the key of ''.// Return the result of stringifying the value.      return str('', {'': value});    };  }// If the JSON object does not yet have a parse method, give it one.  if (typeof JSON.parse !== 'function') {    cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;    JSON.parse = function (text, reviver) {// The parse method takes a text and an optional reviver function, and returns// a JavaScript value if the text is a valid JSON text.      var j;      function walk(holder, key) {// The walk method is used to recursively walk the resulting structure so// that modifications can be made.        var k, v, value = holder[key];        if (value && typeof value === 'object') {          for (k in value) {            if (Object.prototype.hasOwnProperty.call(value, k)) {              v = walk(value, k);              if (v !== undefined) {                value[k] = v;              } else {                delete value[k];              }            }          }        }        return reviver.call(holder, key, value);      }// Parsing happens in four stages. In the first stage, we replace certain// Unicode characters with escape sequences. JavaScript handles many characters// incorrectly, either silently deleting them, or treating them as line endings.      text = String(text);      cx.lastIndex = 0;      if (cx.test(text)) {        text = text.replace(cx, function (a) {          return '\\u' +            ('0000' + a.charCodeAt(0).toString(16)).slice(-4);        });      }// In the second stage, we run the text against regular expressions that look// for non-JSON patterns. We are especially concerned with '()' and 'new'// because they can cause invocation, and '=' because it can cause mutation.// But just to be safe, we want to reject all unexpected forms.// We split the second stage into 4 regexp operations in order to work around// crippling inefficiencies in IE's and Safari's regexp engines. First we// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we// replace all simple value tokens with ']' characters. Third, we delete all// open brackets that follow a colon or comma or that begin the text. Finally,// we look to see that the remaining characters are only whitespace or ']' or// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.      if (/^[\],:{}\s]*$/          .test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')            .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')            .replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {// In the third stage we use the eval function to compile the text into a// JavaScript structure. The '{' operator is subject to a syntactic ambiguity// in JavaScript: it can begin a block or an object literal. We wrap the text// in parens to eliminate the ambiguity.        j = eval('(' + text + ')');// In the optional fourth stage, we recursively walk the new structure, passing// each name/value pair to a reviver function for possible transformation.        return typeof reviver === 'function'          ? walk({'': j}, '')          : j;      }// If the text is not JSON parseable, then a SyntaxError is thrown.      throw new SyntaxError('JSON.parse');    };  }}());function selectedLayersToJSON() {  //var compObj = {};  //compObj.layers = [];  var layers = [];  //Prompt returns a string.   // var sampleRateSec = parseFloat(prompt("How frequently do you want to sample frames (in seconds)?", .1, "Keyframe frequency"));   var sampleRateSec = .02;  if (!sampleRateSec || sampleRateSec < 0) {    sampleRateSec = .02;  }  if (app && app.project && app.project.activeItem) {    //The latest registered time, according to the layers (not the project).    var comp            = app.project.activeItem,    endTime             = comp.duration,    selectedLayers      = comp.selectedLayers;        var sceneName   = prompt("Scene name", comp.name);        sceneName= sceneName.replace(/(^\-+|[^a-zA-Z0-9\/_| -]+|\-+$)/g, '')    .toLowerCase()    .replace(/[\/_| -]+/g, '_')        var sceneDom = sceneName+"Dom"    var initCode        =             'var '+sceneDom+" = $('<div class=\"tm-scene\" id=\""+sceneName+"\" />')\n"+            "this.vpWidth = "+comp.width+";\n"+      "this.vpHeight = "+comp.height+";\n"+      "var layer;\n";            var sourceList = [];              if (selectedLayers) {      //ar frameRate = comp.frameRate;selectedLayersToJSON ()       for(var sl = 0 ; sl < selectedLayers.length ; sl++){              var layer = selectedLayers[sl];                        if (layer instanceof AVLayer) {          var layerObj = {            name:layer.name,            width:layer.source.width,            height:layer.source.height,            start:layer.inPoint,            end:layer.outPoint,            transforms:[]//,            //beziers:[]          }                if(sourceList.indexOf(layer.source === -1))            sourceList.push(layer.source);                cleanLayerName = layer.name.split('#').pop()          spl = cleanLayerName.split(' ')          filename  = spl.length > 1 ? spl[1] : spl[0]          layerName = spl[0]                    finalId = layerName+'-'+i;                    var z_index = (selectedLayers.length-i)*20+100                    initCode+='layer = $("<div class=\'tm-layer\' id=\''+finalId+'\' data-size=\''+layer.source.width+' '+layer.source.height+'\' data-load-image=\'assets/images/scenes/'+sceneName+'/'+filename+'.png\' style=\'z-index:'+z_index+';\' />").prependTo('+sceneDom+')'+"\n"          var hasParentlayer = layer.parent != undefined                              for(var t = layerObj.start; t <= layerObj.end; t+= sampleRateSec) {            //t = t;            var transforms            = getTransformParams(layer, t);            if(hasParentlayer){              parentTransform         = getTransformParams(layer.parent, t);                            transforms.left           = roundVal((parentTransform.left - parentTransform.originX + transforms.left*parentTransform.scaleX)/comp.width*100)+"%"              transforms.top            = roundVal((parentTransform.top  - parentTransform.originY + transforms.top*parentTransform.scaleY)/comp.height*100)+"%"              transforms.rotationZ    += parentTransform.rotationZ               transforms.scaleX       *= parentTransform.scaleX              transforms.scaleY       *= parentTransform.scaleY              //transforms.autoAlpha    *= parentTransform.autoAlpha            }else{              transforms.left            = roundVal(transforms.left/comp.width*100)+"%"              transforms.top            = roundVal(transforms.top/comp.height*100)+"%"            }            layerObj.transforms.push(transforms);          }          layerObj.finalId = finalId;        }        layers.push(layerObj);      }              str = "this.timelineData = {}; \n"      for(var lay = 0; lay < layers.length; lay++) {        var layer = layers[lay];                //first, set the initial properties in frame one.        var initObj         = layer.transforms[0];        initObj.width       = layer.width;        initObj.height      = layer.height;        initObj.xPercent    = roundVal((-layer.transforms[0].originX / layer.width) * 100) + '%';        initObj.yPercent    = roundVal((-layer.transforms[0].originY / layer.height) * 100) + '%';        initObj.transformOrigin = roundVal(layer.transforms[0].originX/layer.width*100) + "% " + roundVal(layer.transforms[0].originY/layer.height*100) +"%";        if (layer.start > 0) {          //Hide this at the beginning.          var hideAtBeginning = true;          layer.transforms[0].display = "none";        } else {          var hideAtBeginning = false;        }        //This layer does not exist the entire duration of the composition.        //Hide it when we're done w/ its frames.        if (layer.end < endTime) {          var hideAtEnd = true;        } else {          var hideAtEnd = false;        }        //Clear these out of the object.        delete initObj.originX;        delete initObj.originY;        delete initObj.time;        str += "/** Tweens for "+layer.finalId+" **/\n";                str += "var tt = '#"+layer.finalId+"'; //tween target\n";        str += "var a = []; \n";        str += "this.timelineData['"+layer.finalId+"'] = a ;\n";        //Conform scale-type items to CSS equivalents.                initObj.width = layer.width;        initObj.height = layer.height;        if(layer.transforms[0].scaleX){          initObj.scaleX = layer.transforms[0].scaleX          initObj.scaleY = layer.transforms[0].scaleY        }                //str += "TweenMax.set(tt, " + JSON.stringify(initObj) + ");\n";        //str += "tl";        for (i in initObj)          if(typeof(initObj[i]) == "number")            initObj[i] = roundVal(initObj[i])        str += "a.push({data:"+JSON.stringify(initObj)+",time:0});\n"        var tr = layer.transforms[0];        prevKeyframe = null        for(var fr = 1; fr < layer.transforms.length; fr++) {          var needsKeyframe   = false;          var keyframe        = {};          //Loop through each of the properties defined in this frame.          //If it has any properties that differ from the frame before it, we need to make a keyframe.          for(var k in layer.transforms[fr]) {            if ((k != "time" &&              k != "originX" &&             k != "originY") &&              (tr[k] == undefined ||               tr[k] != layer.transforms[fr][k])) {              needsKeyframe = true;                            if (k == 'scaleX' || k == 'scaleY' || k =='scale') {                //Don't scale.  Set the width/height instead.                switch(k) {                  case 'scaleX':                    keyframe['scaleX'] = layer.transforms[fr][k];                  break;                  case 'scaleY':                    keyframe['scaleY'] = layer.transforms[fr][k];                  break;                  case 'scale':                    keyframe['width'] = layer.transforms[fr][k] * layer.width;                    keyframe['height'] = layer.transforms[fr][k] * layer.height;                  break;                }              } else {                keyframe[k] = layer.transforms[fr][k];              }            }          }          for (i in keyframe){            if(typeof(keyframe[i]) == "number")              keyframe[i] = roundVal(keyframe[i])            if(prevKeyframe && prevKeyframe[i] == keyframe[i])              delete keyframe[i]                                                              }          prevKeyframe = keyframe          if(!isEmpty(keyframe))            str += "a.push({data:"+(keyframe ? JSON.stringify(keyframe) : "null")+",time:"+roundVal(layer.transforms[fr].time)+"});\n"          tr = layer.transforms[fr];        }        //str += "\n";      }      //str += "\n;"            var finalCode = sceneName+" = {"+        "\tinitDom:function(){\n"+        "\t\t"+initCode.split("\n").join("\t\t\n")+        "\t\tthis.sceneDom = "+sceneDom+";"+        "\t\treturn "+sceneDom+";"+        "},"+        "\tinitTimeline:function(){"+        "\t\t"+str.split("\n").join("\t\t\n")+                "\t\treturn this.timelineData;"+        "}}"      // return;      if (layers.length) {        //var text = JSON.stringify(compObj, null, 2);        var file = File.saveDialog("Save output");        if (file) {          file.open('w');          var fsName = file.fsName;          if (file.write(finalCode) && file.close()) {          } else {            alert("Error writing to file.");          }        } else {          alert("No destination selected. Aborting process.");        }      } else {        alert("No layers were found for conversion.");      }    } else {      alert("No layers selected.\nPlease select layers & re-run script.");    }  } else {    alert("No composition selected.\nPlease select composition & layers & re-run script.");  }}function isEmpty(obj) {    for(var prop in obj) {        if(obj.hasOwnProperty(prop))            return false;    }    return true;}/*--------------------------------------  Bezier props---------------------------------------*/function getBezierParams(layer, time){  var effectList  = layer.Effects;  var effectCount = effectList.numProperties  if (effectCount) {    var props    = [];    for(var i=0; i<effectCount; i++){      var eProp   = effectList.property(i+1);      switch(eProp.matchName) {        case "ADBE BEZMESH":          var bez = [];          // Bezier mesh has 12 props we want          for(var n=0; n<12; n++){            // Should return array?            var vals    = eProp.property(n+1).valueAtTime(time, false);            $.write(vals);            $.write(eProp);            bez.push([vals[0],vals[1]]);          }          props.push(bez);        break;      }    }    return props;  }  return false;}/*--------------------------------------  Layer props---------------------------------------*/function getTransformParams(layer, time){  var tformList   = layer.Transform;  time = time;  var props       = {    time:time  };  //var propsAtTime = "<xform>"  // There are only 5 possible transforms  for(var i=0; i<tformList.numProperties; i++){    var prop    = tformList.property(i+1);    var vals    = prop.valueAtTime(time, false)        switch(prop.name){      case "Point d'ancrage":      case "Anchor Point":        props.originX = vals[0];        props.originY = vals[1];        if (vals[2]) {          props.originZ = vals[2];        }      break;      case "Position":        props.left = vals[0];        props.top = vals[1];        // props.y = vals[1]);        // props.x = vals[0]);        // props.y = vals[1]);        if (vals[2]){          props.z = -vals[2];//-vals[2]);        }        break;      case "Opacite":      case "Opacité":      case "Opacity":        props.autoAlpha = vals / 100;        break;      case "Echelle":      case "Scale":        props.scaleX = vals[0] / 100;        props.scaleY = vals[1] / 100;        if (vals[2]) {          props.scale = vals[2] / 100;        }        break;      case "X Rotation":        props.rotationX = vals;        break;      case "Y Rotation":        props.rotationY = vals;        break;      case "Z Rotation":        props.rotationZ = vals;        break;      case "Rotation":        props.rotationZ  = vals;        break;    }  }  return props;}function roundVal(val){  // Round to 2 decimals.  val *= 1000;  val = Math.round(val);  val /= 1000;  return val;}selectedLayersToJSON();